#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
var(trainFull$Global_active_power[1:50000])
var(data.frame(trainFull$Global_active_power[1:50000]))
trainFull[,1:50000]
trainFull[,trainFull$Global_active_power[1:50000]]
trainFull$Global_active_power[1:50000]
var(trainFull$Global_active_power[1:50000])
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
var(trainSubset)
b
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[1:50000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(0.5280296,2.4104868), sigma = c(0.04487634,1.30667914))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
var(trainSubset)
mean(trainSubset)
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[1:50000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = 1.781638, sigma = 1.673501)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = 1.781638, sigma = 1.673501)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=3
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = 1.781638, sigma = 1.673501)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = 1.781638, sigma = 1.673501)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(0.5103841, 2.1803063), sigma = c(0.03862134, 1.15555651))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
install.packages("mclust")
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(0.5103841, 2.1803063), sigma = c(0.03862134, 1.15555651))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
mean(traindayform$x!=predict(hmm,traindayform$x))
a = sample(c(rep("L",100),rep("R",300)))
a
clear
clr
c
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(0.5103841, 2.1803063), sigma = c(0.03862134, 1.15555651))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
hmm$loglik
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
traindayform
yhat1$x
yhat1$s
yhat2$s
mean(yhat1$s != yhat2$s)
formatMhsmm <- function(data){
nb.sequences = nrow(data)
nb.observations = length(data)
#transform list to data frame
data_df <- data.frame(matrix(unlist(data), nrow = nb.sequences, byrow=F))
#iterate over these in loops
rows <- 1:nb.sequences
observations <- 0:(nb.observations-1)
#build vector with id values
id = numeric(length = nb.sequences*nb.observations )
for(i in rows)
{
for (j in observations)
{
id[i+j+(i-1)*(nb.observations-1)] = i
}
}
#build vector with observation values
sequences = numeric(length = nb.sequences*nb.observations)
for(i in rows)
{
for (j in observations)
{
sequences[i+j+(i-1)*(nb.observations-1)] = data_df[i,j+1]
}
}
data.df = data.frame(id, sequences)
#creation of hsmm.data object needed for training
N <- as.numeric(table(data.df$id))
train <- list(x = data.df$sequences, N = N)
class(train) <- "hsmm.data"
return(train)
}
library(RCurl)
#Get URL's from GitHub for train and test data
trainURL <- getURL("https://raw.githubusercontent.com/CMPT-318/Cybersecurity-Project/master/Data/Train/train.csv")
test1URL <- getURL("https://raw.githubusercontent.com/CMPT-318/Cybersecurity-Project/master/Data/Test/test_v1.csv")
test2URL <- getURL("https://raw.githubusercontent.com/CMPT-318/Cybersecurity-Project/master/Data/Test/test_v2.csv")
#Load csv data into tables
trainFull <- read.csv(text = trainURL)
test1Full <- read.csv(text = test1URL)
test2Full <- read.csv(text = test2URL)
train <- trainFull[, c(2,4)]
train$DateTime <- paste(trainFull$Date, trainFull$Time)
#Format dates
train$DateTime <- as.POSIXct(train$DateTime, format='%d/%m/%Y %H:%M:%S')
train <- na.omit(train)
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[1:50000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(1,4), sigma = c(2,1))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
modelbased <- predict(startmodel,train,method="smoothed" )
plot(modelbased)
addstates(yhat1$s)
library(zoo)
library(xts)
library(dplyr)
library(ggplot2)
library(lubridate)
apply.hourly <- function(x, FUN,...) {
ep <- endpoints(x, 'hours')
period.apply(x, ep, FUN, ...)
}
trainTS <- xts(train$Global_active_power, order.by = train$DateTime)
minutes <- fortify(trainTS)
hourly <- fortify(apply.hourly(trainTS,mean))
daily <- fortify(apply.daily(trainTS,mean))
monthly <- fortify(apply.monthly(trainTS,mean))
colnames(minutes) <- c("Date", "Global_active_power")
colnames(hourly) <- c("Date", "Global_active_power")
colnames(daily) <- c("Date", "Global_active_power")
colnames(monthly) <- c("Date", "Global_active_power")
trainHourly <- hourly
formatMhsmm <- function(data){
nb.sequences = nrow(data)
nb.observations = length(data)
#transform list to data frame
data_df <- data.frame(matrix(unlist(data), nrow = nb.sequences, byrow=F))
#iterate over these in loops
rows <- 1:nb.sequences
observations <- 0:(nb.observations-1)
#build vector with id values
id = numeric(length = nb.sequences*nb.observations )
for(i in rows)
{
for (j in observations)
{
id[i+j+(i-1)*(nb.observations-1)] = i
}
}
#build vector with observation values
sequences = numeric(length = nb.sequences*nb.observations)
for(i in rows)
{
for (j in observations)
{
sequences[i+j+(i-1)*(nb.observations-1)] = data_df[i,j+1]
}
}
data.df = data.frame(id, sequences)
#creation of hsmm.data object needed for training
N <- as.numeric(table(data.df$id))
train <- list(x = data.df$sequences, N = N)
class(train) <- "hsmm.data"
return(train)
}
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[1:50000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(1,4), sigma = c(2,1))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
library(RCurl)
#Get URL's from GitHub for train and test data
trainURL <- getURL("https://raw.githubusercontent.com/CMPT-318/Cybersecurity-Project/master/Data/Train/train.csv")
test1URL <- getURL("https://raw.githubusercontent.com/CMPT-318/Cybersecurity-Project/master/Data/Test/test_v1.csv")
test2URL <- getURL("https://raw.githubusercontent.com/CMPT-318/Cybersecurity-Project/master/Data/Test/test_v2.csv")
#Load csv data into tables
trainFull <- read.csv(text = trainURL)
test1Full <- read.csv(text = test1URL)
test2Full <- read.csv(text = test2URL)
train <- trainFull[, c(2,4)]
train$DateTime <- paste(trainFull$Date, trainFull$Time)
#Format dates
train$DateTime <- as.POSIXct(train$DateTime, format='%d/%m/%Y %H:%M:%S')
train <- na.omit(train)
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[1:50000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(1,4), sigma = c(2,1))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
yhat2$loglik
yhat1$loglik
