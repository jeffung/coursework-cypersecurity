yhat4 <- predict(hmm_14, tmp)
lLikelihood[i, 4] <- yhat4$loglik
}
for (i in 1:4) {
interval[1,i] <- max(lLikelihood[, i])
interval[2,i] <- min(lLikelihood[, i])
LLmean[i] <- mean(lLikelihood[, i])
}
View(interval)
View(interval)
interval
LLmean
library(RCurl)
#Get URL's from GitHub for train and test data
trainURL <- getURL("https://raw.githubusercontent.com/CMPT-318/Cybersecurity-Project/master/Data/Train/train.txt")
test1URL <- getURL("https://raw.githubusercontent.com/CMPT-318/Cybersecurity-Project/master/Data/Test/test1.txt")
test2URL <- getURL("https://raw.githubusercontent.com/CMPT-318/Cybersecurity-Project/master/Data/Test/test2.txt")
#Load csv data into tables
trainFull <- read.table(text = trainURL, sep = ",", header = TRUE)
test1Full <- read.table(text = test1URL, sep = ",", header = TRUE)
test2Full <- read.table(text = test2URL, sep = ",", header = TRUE)
rm(trainURL)
rm(test1URL)
rm(test2URL)
formatMhsmm <- function(data){
nb.sequences = nrow(data)
nb.observations = length(data)
#transform list to data frame
data_df <- data.frame(matrix(unlist(data), nrow = nb.sequences, byrow=F))
#iterate over these in loops
rows <- 1:nb.sequences
observations <- 0:(nb.observations-1)
#build vector with id values
id = numeric(length = nb.sequences*nb.observations )
for(i in rows)
{
for (j in observations)
{
id[i+j+(i-1)*(nb.observations-1)] = i
}
}
#build vector with observation values
sequences = numeric(length = nb.sequences*nb.observations)
for(i in rows)
{
for (j in observations)
{
sequences[i+j+(i-1)*(nb.observations-1)] = data_df[i,j+1]
}
}
data.df = data.frame(id, sequences)
#creation of hsmm.data object needed for training
N <- as.numeric(table(data.df$id))
train <- list(x = data.df$sequences, N = N)
class(train) <- "hsmm.data"
return(train)
}
library(mhsmm)
validationset <- trainFull$Global_active_power[(nrow(trainFull)*0.9):nrow(trainFull)]
corrupt <- rbinom(length(validationset),1,0.006)
corrupt <- as.logical(corrupt)
maxflownoise <- rnorm(sum(corrupt),12,1)
minflownoise <- rnorm(sum(corrupt),0,0.1)
validationset[corrupt] <- validationset[corrupt] + minflownoise + maxflownoise
validationset
library(mhsmm)
library(dplyr)
library(lubridate)
train <- trainFull[, c(1,3)]
colnames(train) <- c("DateTime", "Global_active_power")
train$DateTime <- paste(trainFull$Date, trainFull$Time)
train$DateTime <- as.POSIXct(train$DateTime, format='%d/%m/%Y %H:%M:%S')
train <- na.omit(train)
traindayform <- formatMhsmm(data.frame(train$Global_active_power))
# number of states HMM
k=8
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
muVec <- c(0.3301653, 0.2730533, 4.5924386, 0.8581603, 2.1744369, 3.1150939, 0.5493970, 1.7928395)
sigmaVec <- c(0.0201126908, 0.0029628074, 1.1349055417, 0.1301456018, 0.2770119212, 0.3368303610, 0.0008511606, 0.0424565463)
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm_8 <- hmmfit(traindayform$x, startmodel, mstep = mstep.norm,maxit = 200, tol=1e-02)
#print resulting HMM parameters
summary(hmm_8)
plot(hmm_8$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#yhat1 <- predict (hmm_8,traindayform$x)
#yhat2 <- predict (hmm_8,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm_8$loglik[length(hmm_8$loglik)]
which(corrupt == TRUE)
if (corrupt[6]) {
TRUE
}
if (corrupt[7]) {
TRUE
}
else {
FALSE
}
if (corrupt[7]) {
TRUE
} else {
FALSE
}
length(corrupt)
length(which(corrupt == TRUE))
result <- predict (hmm,validationset)
result <- predict (hmm_8,validationset)
result$s[1]
hmm_8$model$parms.emission$mu[3]
result$s
difference <- 0
probability <- 0
threshold <- 1
probThreshold <- 0.65
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
for (i in 1:length(validationset)) {
state <- result$s[i]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference[i] <- abs(expected - validationset[i])
probability <- difference/(alpha * threshold)
if (probability >= probThreshold) {
detectedAnomalies <- detectedAnomalies + 1
if (corrupt[i]) {
actualAnomalies <- actualAnomalies + 1
}
}
}
precision <- actualAnomalies / detectedAnomalies
recall <- actualAnomalies / totalAnomalies
precision
recall
probability <- 0
difference <- 0
probability <- 0
threshold <- 1
probThreshold <- 0.65
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
for (i in 1:length(validationset)) {
state <- result$s[i]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference[i] <- abs(expected - validationset[i])
probability <- difference/(alpha * threshold)
if (probability >= probThreshold) {
detectedAnomalies <- detectedAnomalies + 1
if (corrupt[i]) {
actualAnomalies <- actualAnomalies + 1
}
}
}
difference <- 0
probability <- 0
threshold <- 1
probThreshold <- 0.65
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
for (i in 1:length(validationset)) {
state <- result$s[i]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference[i] <- abs(expected - validationset[i])
probability <- difference/(alpha * threshold)
if (probability >= probThreshold) {
detectedAnomalies <- detectedAnomalies + 1
if (corrupt[i]) {
actualAnomalies <- actualAnomalies + 1
}
}
}
difference <- 0
probability <- 0
threshold <- 1
probThreshold <- 0.65
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
for (i in 1:length(validationset)) {
browser()
state <- result$s[i]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference[i] <- abs(expected - validationset[i])
probability <- difference/(alpha * threshold)
if (probability >= probThreshold) {
detectedAnomalies <- detectedAnomalies + 1
if (corrupt[i]) {
actualAnomalies <- actualAnomalies + 1
}
}
}
precision <- actualAnomalies / detectedAnomalies
recall <- actualAnomalies / totalAnomalies
precision
recall
exit
q
quit()
difference <- 0
probability <- c(1:length(validationset))
threshold <- 1
probThreshold <- 0.65
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
difference <- 0
probability <- c(1:length(validationset))
threshold <- 1
probThreshold <- 0.65
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
difference <- 0
probability <- 0
threshold <- 1
probThreshold <- 0.65
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
state <- result$s[2]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[2])
probability <- difference/(alpha * threshold)
state <- result$s[6]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[2])
probability <- difference/(alpha * threshold)
state <- result$s[3]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[2])
probability <- difference/(alpha * threshold)
state <- result$s[3]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[3])
probability <- difference/(alpha * threshold)
state <- result$s[6]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[6])
probability <- difference/(alpha * threshold)
state <- result$s[3]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[3])
state <- result$s[3]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[3])
probability <- difference/(sqrt(alpha) * threshold)
state <- result$s[2]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[2])
probability <- difference/(sqrt(alpha) * threshold)
state <- result$s[4]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[4])
probability <- difference/(sqrt(alpha) * threshold)
state <- result$s[5]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[5])
probability <- difference/(sqrt(alpha) * threshold)
state <- result$s[6]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[6])
probability <- difference/(sqrt(alpha) * threshold)
state <- result$s[6]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[6])
probability <- difference/(sqrt(alpha) * 2 * threshold)
state <- result$s[2]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[2])
probability <- difference/(sqrt(alpha) * 2 * threshold)
state <- result$s[3]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[3])
probability <- difference/(sqrt(alpha) * 2 * threshold)
state <- result$s[4]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[4])
probability <- difference/(sqrt(alpha) * 2 * threshold)
state <- result$s[5]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[5])
probability <- difference/(sqrt(alpha) * 2 * threshold)
state <- result$s[7]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[7])
probability <- difference/(sqrt(alpha) * 2 * threshold)
state <- result$s[8]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[8])
probability <- difference/(sqrt(alpha) * 2 * threshold)
difference <- 0
probability <- 0
threshold <- 1
probThreshold <- 0.75
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
for (i in 1:length(validationset)) {
state <- result$s[i]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[i])
probability <- difference / (sqrt(alpha) * 2 * threshold)
if (probability >= probThreshold) {
detectedAnomalies <- detectedAnomalies + 1
if (corrupt[i]) {
actualAnomalies <- actualAnomalies + 1
}
}
}
precision <- actualAnomalies / detectedAnomalies
recall <- actualAnomalies / totalAnomalies
precision
recall
difference <- 0
probability <- 0
threshold <- 1
probThreshold <- 0.75
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
for (i in 1:length(validationset)) {
state <- result$s[i]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[i])
#  probability <- difference / (sqrt(alpha) * 2 * threshold)
if (difference >= threshold) {
detectedAnomalies <- detectedAnomalies + 1
if (corrupt[i]) {
actualAnomalies <- actualAnomalies + 1
}
}
}
precision <- actualAnomalies / detectedAnomalies
recall <- actualAnomalies / totalAnomalies
precision
recall
difference <- 0
probability <- 0
threshold <- 1.5
probThreshold <- 0.75
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
for (i in 1:length(validationset)) {
state <- result$s[i]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[i])
#  probability <- difference / (sqrt(alpha) * 2 * threshold)
if (difference >= threshold) {
detectedAnomalies <- detectedAnomalies + 1
if (corrupt[i]) {
actualAnomalies <- actualAnomalies + 1
}
}
}
precision <- actualAnomalies / detectedAnomalies
recall <- actualAnomalies / totalAnomalies
precision
recall
difference <- 0
probability <- 0
threshold <- 2
probThreshold <- 0.75
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
for (i in 1:length(validationset)) {
state <- result$s[i]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[i])
#  probability <- difference / (sqrt(alpha) * 2 * threshold)
if (difference >= threshold) {
detectedAnomalies <- detectedAnomalies + 1
if (corrupt[i]) {
actualAnomalies <- actualAnomalies + 1
}
}
}
precision <- actualAnomalies / detectedAnomalies
recall <- actualAnomalies / totalAnomalies
precision
recall
difference <- 0
probability <- 0
threshold <- 2
probThreshold <- 0.75
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
for (i in 1:length(validationset)) {
state <- result$s[i]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[i])
probability <- difference / (sqrt(alpha) * threshold)
if (difference >= threshold) {
detectedAnomalies <- detectedAnomalies + 1
if (corrupt[i]) {
actualAnomalies <- actualAnomalies + 1
}
}
}
precision <- actualAnomalies / detectedAnomalies
recall <- actualAnomalies / totalAnomalies
precision
recall
difference <- 0
probability <- 0
threshold <- 2
probThreshold <- 0.75
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
for (i in 1:length(validationset)) {
state <- result$s[i]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[i])
probability <- difference / (sqrt(alpha) * threshold)
if (probability >= probThreshold) {
detectedAnomalies <- detectedAnomalies + 1
if (corrupt[i]) {
actualAnomalies <- actualAnomalies + 1
}
}
}
precision <- actualAnomalies / detectedAnomalies
recall <- actualAnomalies / totalAnomalies
precision
recall
difference <- 0
threshold <- 2
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
for (i in 1:length(validationset)) {
state <- result$s[i]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[i])
if (difference >= threshold) {
detectedAnomalies <- detectedAnomalies + 1
if (corrupt[i]) {
actualAnomalies <- actualAnomalies + 1
}
}
}
precision <- actualAnomalies / detectedAnomalies
recall <- actualAnomalies / totalAnomalies
precision
recall
difference <- 0
threshold <- 2
totalAnomalies <- length(which(corrupt == TRUE))
detectedAnomalies <- 0
actualAnomalies <- 0
for (i in 1:length(validationset)) {
state <- result$s[i]
expected <- hmm_8$model$parms.emission$mu[state]
alpha <- hmm_8$model$parms.emission$sigma[state]
difference <- abs(expected - validationset[i])
if (difference >= threshold) {
detectedAnomalies <- detectedAnomalies + 1
if (corrupt[i]) {
actualAnomalies <- actualAnomalies + 1
}
}
}
precision <- actualAnomalies / detectedAnomalies
recall <- actualAnomalies / totalAnomalies
fScore <- (2 * precision * recall) / (precision + recall)
precision
recall
fScore
