colnames(averageSummerDay) <- c("Day", "Global_active_power")
averageWinterDay <- cbind(c(1:28),c(1:28))
colnames(averageWinterDay) <- c("Day", "Global_active_power")
averageSummerDay <- cbind(c(1:28),c(1:28))
colnames(averageSummerDay) <- c("Day", "Global_active_power")
averageWinterDay <- cbind(c(1:28),c(1:28))
colnames(averageWinterDay) <- c("Day", "Global_active_power")
for (i in 1:28) {
tmp <- with(minutes, minutes[day(Date) == i & month(Date) >= 6 & month(Date) <= 9, ])
averageSummerDay[i,2] <- mean(tmp$Global_active_power, na.rm = TRUE)
tmp <- with(minutes, minutes[day(Date) == i & month(Date) <= 2 | month(Date) >= 11, ])
averageWinterDay[i,2] <- mean(tmp$Global_active_power, na.rm = TRUE)
}
rm(tmp)
par(mfrow=c(2,1))
plot(averageSummerDay, xlab="Summer", ylab="Average Global Active Power (kW)", col="red", type="l")
plot(averageWinterDay, xlab="Winter", ylab="Average Global Active Power (kW)", col="green", type="l")
par(mfrow=c(2,1))
plot(averageSummerDay, xlab="Day of the Month - Summer", ylab="Average Global Active Power (kW)", col="red", type="l")
plot(averageWinterDay, xlab="Day of the Month - Winter", ylab="Average Global Active Power (kW)", col="green", type="l")
muVec <- c(1:k)
sigmaVec <- c(1:k)
muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
1.131033014, 0.002118213)
muVec[1] <- muVec[1] * 0.88
sigmaVec[1] <- sigmaVec[1] * 0.88
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
muVec <- c(1:k)
sigmaVec <- c(1:k)
muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
1.131033014, 0.002118213)
muVec[1] <- muVec[1] * 0.89
sigmaVec[1] <- sigmaVec[1] * 0.89
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
k=13
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502, 0.5)
sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
1.131033014, 0.002118213, 0.002)
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
k=13
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502, 0.5)
sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
1.131033014, 0.002118213, 0.002)
muVec[1] <- muVec[1] * 1.5
sigmaVec[1] <- sigmaVec[1] * 1.5
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
hmm$loglik
k=13
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
#Best so far
#muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
#sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
#              1.131033014, 0.002118213)
muVec <- c(0.7679974, 0.2728960, 2.3293536, 1.5117650, 1.8322461, 1.0212876, 3.2997456, 0.5121756, 1.2305494, 0.1715910, 4.7432124,
0.4516749, 0.5430536)
sigmaVec <- c(0.0365074502, 0.0026250756, 0.2583127302, 0.0234393054, 0.0541526317, 0.2804007965, 0.3208342031, 0.0214031650, 0.0214245905,
0.0035929165, 1.1397967931, 0.0017180449, 0.0006006523)
muVec[2] <- muVec[2] * 1.5
sigmaVec[2] <- sigmaVec[2] * 1.5
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
k=13
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
#Best so far
#muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
#sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
#              1.131033014, 0.002118213)
muVec <- c(0.7679974, 0.2728960, 2.3293536, 1.5117650, 1.8322461, 1.0212876, 3.2997456, 0.5121756, 1.2305494, 0.1715910, 4.7432124,
0.4516749, 0.5430536)
sigmaVec <- c(0.0365074502, 0.0026250756, 0.2583127302, 0.0234393054, 0.0541526317, 0.2804007965, 0.3208342031, 0.0214031650, 0.0214245905,
0.0035929165, 1.1397967931, 0.0017180449, 0.0006006523)
muVec[2] <- muVec[2] * 0.5
sigmaVec[2] <- sigmaVec[2] * 0.5
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
muVec <- c(0.7679974, 0.2728960, 2.3293536, 1.5117650, 1.8322461, 1.0212876, 3.2997456, 0.5121756, 1.2305494, 0.1715910, 4.7432124,
0.4516749, 0.5430536)
sigmaVec <- c(0.0365074502, 0.0026250756, 0.2583127302, 0.0234393054, 0.0541526317, 0.2804007965, 0.3208342031, 0.0214031650, 0.0214245905,
0.0035929165, 1.1397967931, 0.0017180449, 0.0006006523)
muVec[7] <- muVec[2] * 0.5
sigmaVec[7] <- sigmaVec[2] * 0.5
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
muVec <- c(0.7679974, 0.2728960, 2.3293536, 1.5117650, 1.8322461, 1.0212876, 3.2997456, 0.5121756, 1.2305494, 0.1715910, 4.7432124,
0.4516749, 0.5430536)
sigmaVec <- c(0.0365074502, 0.0026250756, 0.2583127302, 0.0234393054, 0.0541526317, 0.2804007965, 0.3208342031, 0.0214031650, 0.0214245905,
0.0035929165, 1.1397967931, 0.0017180449, 0.0006006523)
muVec[7] <- muVec[7] * 0.5
sigmaVec[7] <- sigmaVec[7] * 0.5
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
muVec <- c(0.7679974, 0.2728960, 2.3293536, 1.5117650, 1.8322461, 1.0212876, 3.2997456, 0.5121756, 1.2305494, 0.1715910, 4.7432124,
0.4516749, 0.5430536)
sigmaVec <- c(0.0365074502, 0.0026250756, 0.2583127302, 0.0234393054, 0.0541526317, 0.2804007965, 0.3208342031, 0.0214031650, 0.0214245905,
0.0035929165, 1.1397967931, 0.0017180449, 0.0006006523)
muVec[4] <- muVec[4] * 0.4
sigmaVec[4] <- sigmaVec[4] * 0.4
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
k=13
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
#Best so far
#muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
#sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
#              1.131033014, 0.002118213)
muVec <- c(0.7679974, 0.2728960, 2.3293536, 1.5117650, 1.8322461, 1.0212876, 3.2997456, 0.5121756, 1.2305494, 0.1715910, 4.7432124,
0.4516749, 0.5430536)
sigmaVec <- c(0.0365074502, 0.0026250756, 0.2583127302, 0.0234393054, 0.0541526317, 0.2804007965, 0.3208342031, 0.0214031650, 0.0214245905,
0.0035929165, 1.1397967931, 0.0017180449, 0.0006006523)
muVec[4] <- muVec[4] * 0.4
sigmaVec[4] <- sigmaVec[4] * 0.4
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
k=13
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
#Best so far
#muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
#sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
#              1.131033014, 0.002118213)
muVec <- c(0.7679974, 0.2728960, 2.3293536, 0.5758438, 1.8322461, 1.0212876, 3.2997456, 0.5121756, 1.2305494, 0.1715910, 4.7432124,
0.4516749, 0.5430536)
sigmaVec <- c(0.0365074502, 0.0026250756, 0.2834291148, 0.0234393054, 0.0541526317, 0.2804007965, 0.3208342031, 0.0214031650, 0.0214245905,
0.0035929165, 1.1397967931, 0.0017180449, 0.0006006523)
muVec[3] <- muVec[3] * 0.5
sigmaVec[3] <- sigmaVec[3] * 0.5
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
muVec <- c(0.5447714, 0.2728960, 2.3293536, 1.5501700, 0.5594927, 1.0212876, 3.2997456, 0.5121756, 1.2305494, 0.1715910, 4.7432124,
0.4516749, 0.5430536)
sigmaVec <- c(0.000668871, 0.0026250756, 0.486437022, 0.0234393054, 0.026516903, 0.2804007965, 0.3208342031, 0.0214031650, 0.0214245905,
0.0035929165, 1.1397967931, 0.0017180449, 0.0006006523)
#muVec[3] <- muVec[3] * 0.5
#sigmaVec[3] <- sigmaVec[3] * 0.5
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
k=12
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
1.131033014, 0.002118213)
muVec[1] <- muVec[1] * 0.88
sigmaVec[1] <- sigmaVec[1] * 0.88
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
k=12
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
1.131033014, 0.002118213)
muVec[10] <- muVec[10] * 0.88
sigmaVec[10] <- sigmaVec[10] * 0.88
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
rm(testSim)
k=12
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
1.131033014, 0.002118213)
muVec[3] <- muVec[3] * 0.88
sigmaVec[3] <- sigmaVec[3] * 0.88
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
k=12
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
1.131033014, 0.002118213)
muVec[2] <- muVec[2] * 0.85
sigmaVec[2] <- sigmaVec[2] * 0.85
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
1.131033014, 0.002118213)
muVec[7] <- muVec[7] * 0.85
sigmaVec[7] <- sigmaVec[7] * 0.85
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
k=12
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
1.131033014, 0.002118213)
muVec[4] <- muVec[4] * 0.85
sigmaVec[4] <- sigmaVec[4] * 0.85
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
k=12
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
muVec <- c(1:k)
sigmaVec <- c(1:k)
muVec <- c(0.5447714, 0.2779779, 1.8263834, 1.5501700, 1.9615561, 0.8685399, 2.7655574, 0.5594927, 1.2849762, 0.1710025, 4.1631672, 0.4510502)
sigmaVec <- c(0.000668871, 0.002888363, 0.486437022, 0.026234604, 0.061892010, 0.129187716, 0.235773146, 0.026516903, 0.020386461, 0.003444033,
1.131033014, 0.002118213)
muVec[3] <- muVec[3] * 0.85
sigmaVec[3] <- sigmaVec[3] * 0.85
b <- list(mu = muVec, sigma = sigmaVec)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200,tol=1e-02)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,test1form$x)
#plot(yhat1)
#plot(yhat2)
hmm$loglik[length(hmm$loglik)]
