july <- daily %>% filter(Date >= "2007-07-01 23:59:00" & Date <= "2007-07-31 23:59:00")
january <- daily %>% filter(Date >= "2007-01-01 23:59:00" & Date <= "2007-01-31 23:59:00")
july <- daily %>% filter(Date >= "2007-07-01 23:59:00" & Date <= "2007-07-31 23:59:00")
par(mfrow=c(2,1))
z <- read.zoo(january, header = TRUE)
plot(z, xaxt="n", ylab="Average Global Active Power", xlab="January", col="red", plot.type = "single")
axis(1, january$Date, format(as.Date(january$Date), "%b %y"),  cex.axis = .7)
z <- read.zoo(july, header = TRUE)
plot(z, xaxt="n", ylab="Average Global Active Power", xlab="July", col="red", plot.type = "single")
axis(1, july$Date, format(as.Date(july$Date), "%b %y"),  cex.axis = .7)
january <- daily %>% filter(Date >= "2007-01-01 23:59:00" & Date <= "2007-01-31 23:59:00")
july <- daily %>% filter(Date >= "2007-07-01 23:59:00" & Date <= "2007-07-31 23:59:00")
par(mfrow=c(2,1))
z <- read.zoo(january, header = TRUE)
plot(z, xaxt="n", ylab="Average Global Active Power", xlab="January", col="red", plot.type = "single")
axis(1, january$Date, format(as.Date(january$Date), "%b %d"),  cex.axis = .7)
z <- read.zoo(july, header = TRUE)
plot(z, xaxt="n", ylab="Average Global Active Power", xlab="July", col="red", plot.type = "single")
axis(1, july$Date, format(as.Date(july$Date), "%b %d"),  cex.axis = .7)
january <- daily %>% filter(Date >= "2007-01-01 23:59:00" & Date <= "2007-01-31 23:59:00")
july <- daily %>% filter(Date >= "2007-07-01 23:59:00" & Date <= "2007-07-31 23:59:00")
par(mfrow=c(2,1))
z <- read.zoo(january, header = TRUE)
plot(z, xaxt="n", ylab="Average Global Active Power", xlab="January", col="red", plot.type = "single")
axis(1, january$Date, format(as.Date(january$Date), "%b %d"),  cex.axis = .7)
z <- read.zoo(july, header = TRUE)
plot(z, xaxt="n", ylab="Average Global Active Power", xlab="July", col="green", plot.type = "single")
axis(1, july$Date, format(as.Date(july$Date), "%b %d"),  cex.axis = .7)
View(hourly)
View(hourly)
january <- hourly %>% filter(Date >= "2007-01-01 00:59:00" & Date <= "2007-01-31 23:59:00")
july <- hourly %>% filter(Date >= "2007-07-01 00:59:00" & Date <= "2007-07-31 23:59:00")
par(mfrow=c(2,1))
z <- read.zoo(january, header = TRUE)
plot(z, xaxt="n", ylab="Average Global Active Power", xlab="January", col="red", plot.type = "single")
axis(1, january$Date, format(as.Date(january$Date), "%b %d"),  cex.axis = .7)
z <- read.zoo(july, header = TRUE)
plot(z, xaxt="n", ylab="Average Global Active Power", xlab="July", col="green", plot.type = "single")
axis(1, july$Date, format(as.Date(july$Date), "%b %d"),  cex.axis = .7)
View(trainFull)
minutes <- fortify(trainTS)
View(minutes)
View(minutes)
JanDay <- minutes %>% filter(Date >= '2007-01-09 00:59:00' & Date <= '2007-01-09 23:59:00')
JanDay$Date <- strftime(JanDay$Date, format="%H:%M:%S")
JanDay$Date <- as.POSIXct(JanDay$Date, format="%H:%M:%S")
JulyDay <- minutes %>% filter(Date >= '2007-07-09 00:59:00' & Date <= '2007-07-09 23:59:00')
JulyDay$Date <- strftime(JulyDay$Date, format="%H:%M:%S")
JulyDay$Date <- as.POSIXct(JulyDay$Date, format="%H:%M:%S")
total <- merge(x = JanDay, y = JulyDay, by = "Date", all.x = TRUE)
colnames(total) <- c("Date", "Jan 9, 2007", "July 9, 2007")
z <- read.zoo(total, header = TRUE)
plot(z, xaxt = "n", ylab="Average Global Active Power", xlab="Time of Day", col=c("red","green"), plot.type = "single")
axis(1, total$Date, format(total$Date, "%H:%M:%S"), cex.axis = .7)
legend('topleft', names(total)[-1] ,lty=1, col=c("red","green"), bty='n', cex=.75)
colnames(minutes) <- c("Date", "Global_active_power")
JanDay <- minutes %>% filter(Date >= '2007-01-09 00:59:00' & Date <= '2007-01-09 23:59:00')
JanDay$Date <- strftime(JanDay$Date, format="%H:%M:%S")
JanDay$Date <- as.POSIXct(JanDay$Date, format="%H:%M:%S")
JulyDay <- minutes %>% filter(Date >= '2007-07-09 00:59:00' & Date <= '2007-07-09 23:59:00')
JulyDay$Date <- strftime(JulyDay$Date, format="%H:%M:%S")
JulyDay$Date <- as.POSIXct(JulyDay$Date, format="%H:%M:%S")
total <- merge(x = JanDay, y = JulyDay, by = "Date", all.x = TRUE)
colnames(total) <- c("Date", "Jan 9, 2007", "July 9, 2007")
z <- read.zoo(total, header = TRUE)
plot(z, xaxt = "n", ylab="Average Global Active Power", xlab="Time of Day", col=c("red","green"), plot.type = "single")
axis(1, total$Date, format(total$Date, "%H:%M:%S"), cex.axis = .7)
legend('topleft', names(total)[-1] ,lty=1, col=c("red","green"), bty='n', cex=.75)
JanDay <- minutes %>% filter(Date >= '2007-01-09 00:59:00' & Date <= '2007-01-09 23:59:00')
JanDay$Date <- strftime(JanDay$Date, format="%H:%M:%S")
JanDay$Date <- as.POSIXct(JanDay$Date, format="%H:%M:%S")
JulyDay <- minutes %>% filter(Date >= '2007-07-09 00:59:00' & Date <= '2007-07-09 23:59:00')
JulyDay$Date <- strftime(JulyDay$Date, format="%H:%M:%S")
JulyDay$Date <- as.POSIXct(JulyDay$Date, format="%H:%M:%S")
total <- merge(x = JanDay, y = JulyDay, by = "Date", all.x = TRUE)
colnames(total) <- c("Date", "Jan 9, 2007", "July 9, 2007")
z <- read.zoo(total, header = TRUE)
plot(z, xaxt = "n", ylab="Average Global Active Power", xlab="Time of Day", col=c("red","green"), plot.type = "single")
axis(1, total$Date, format(total$Date, "%H:%M:%S"), cex.axis = .7)
legend('topleft', names(total)[-1] ,lty=1, col=c("red","green"), bty='n', cex=.75)
JanDay <- hourly %>% filter(Date >= '2007-01-09 00:59:00' & Date <= '2007-01-09 23:59:00')
JanDay$Date <- strftime(JanDay$Date, format="%H:%M:%S")
JanDay$Date <- as.POSIXct(JanDay$Date, format="%H:%M:%S")
JulyDay <- hourly %>% filter(Date >= '2007-07-09 00:59:00' & Date <= '2007-07-09 23:59:00')
JulyDay$Date <- strftime(JulyDay$Date, format="%H:%M:%S")
JulyDay$Date <- as.POSIXct(JulyDay$Date, format="%H:%M:%S")
total <- merge(x = JanDay, y = JulyDay, by = "Date", all.x = TRUE)
colnames(total) <- c("Date", "Jan 9, 2007", "July 9, 2007")
z <- read.zoo(total, header = TRUE)
plot(z, xaxt = "n", ylab="Average Global Active Power", xlab="Time of Day", col=c("red","green"), plot.type = "single")
axis(1, total$Date, format(total$Date, "%H:%M:%S"), cex.axis = .7)
legend('topleft', names(total)[-1] ,lty=1, col=c("red","green"), bty='n', cex=.75)
data.frame(train$Global_active_power[1:50000])
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
traindayform <- formatMhsmm(data.frame(train$Global_active_power[1:50000]))
testdayform <- formatMhsmm(data.frame(test1$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(1,4), sigma = c(2,1))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
formatMhsmm <- function(data){
nb.sequences = nrow(data)
nb.observations = length(data)
#transform list to data frame
data_df <- data.frame(matrix(unlist(data), nrow = nb.sequences, byrow=F))
#iterate over these in loops
rows <- 1:nb.sequences
observations <- 0:(nb.observations-1)
#build vector with id values
id = numeric(length = nb.sequences*nb.observations )
for(i in rows)
{
for (j in observations)
{
id[i+j+(i-1)*(nb.observations-1)] = i
}
}
#build vector with observation values
sequences = numeric(length = nb.sequences*nb.observations)
for(i in rows)
{
for (j in observations)
{
sequences[i+j+(i-1)*(nb.observations-1)] = data_df[i,j+1]
}
}
data.df = data.frame(id, sequences)
#creation of hsmm.data object needed for training
N <- as.numeric(table(data.df$id))
train <- list(x = data.df$sequences, N = N)
class(train) <- "hsmm.data"
return(train)
}
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
traindayform <- formatMhsmm(data.frame(train$Global_active_power[1:50000]))
testdayform <- formatMhsmm(data.frame(test1$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(1,4), sigma = c(2,1))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
testdayform <- formatMhsmm(data.frame(test1$Global_active_power[1:1000]))
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[1:50000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(1,4), sigma = c(2,1))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
var(trainFull$Global_active_power[1:50000])
var(data.frame(trainFull$Global_active_power[1:50000]))
trainFull[,1:50000]
trainFull[,trainFull$Global_active_power[1:50000]]
trainFull$Global_active_power[1:50000]
var(trainFull$Global_active_power[1:50000])
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
var(trainSubset)
b
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[1:50000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(0.5280296,2.4104868), sigma = c(0.04487634,1.30667914))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
var(trainSubset)
mean(trainSubset)
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[1:50000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = 1.781638, sigma = 1.673501)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = 1.781638, sigma = 1.673501)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=3
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = 1.781638, sigma = 1.673501)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = 1.781638, sigma = 1.673501)
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(0.5103841, 2.1803063), sigma = c(0.03862134, 1.15555651))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
install.packages("mclust")
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(0.5103841, 2.1803063), sigma = c(0.03862134, 1.15555651))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
mean(traindayform$x!=predict(hmm,traindayform$x))
a = sample(c(rep("L",100),rep("R",300)))
a
clear
clr
c
library(mhsmm)
#dataset <- read.csv('file.csv',header=TRUE)
#train <- formatMhsmm(data.frame(TotalFlow$FlowLevel))
#day subset
trainSubset <- na.omit(trainFull$Global_active_power[1:50000])
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
testdayform <- formatMhsmm(data.frame(test1Full$Global_active_power[1:1000]))
#end of data
# 4 states HMM
k=2
#init probabilities
init <- rep(1/k, k)
#transition matrix
P <- matrix(rep(1/k, k*k), nrow = k)
#emission matrix:  here I used a Gaussian distribution, replace muEst and sigmaEst by your initial estimates of mean and variance
b <- list(mu = c(0.5103841, 2.1803063), sigma = c(0.03862134, 1.15555651))
#starting model for EM
startmodel <- hmmspec(init = init, trans = P, parms.emis = b, dens.emis = dnorm.hsmm)
startmodel
#EM algorithm fits an HMM to the data
hmm <- hmmfit(traindayform$x, startmodel , mstep = mstep.norm,maxit = 200)
#print resulting HMM parameters
summary(hmm)
plot(hmm$loglik, type="b", ylab="log-likelihood", xlab="Iteration")
#testhmm1 <- formatMhsmm(test)
yhat1 <- predict (hmm,traindayform$x)
yhat2 <- predict (hmm,testdayform$x)
#modelbased <- predict(startmodel,train,method="smoothed" )
#plot(modelbased)
plot(yhat1)
#addstates(yhat1$s)
plot(yhat2)
#addstates(yhat2$s)
hmm$loglik
traindayform <- formatMhsmm(data.frame(trainFull$Global_active_power[50001:100000]))
traindayform
yhat1$x
yhat1$s
yhat2$s
mean(yhat1$s != yhat2$s)
